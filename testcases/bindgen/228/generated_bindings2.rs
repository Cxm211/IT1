/* automatically generated by rust-bindgen 0.71.1 */

#[doc = r" If Bindgen could only determine the size and alignment of a"]
#[doc = r" type, it is represented like this."]
#[derive(PartialEq, Copy, Clone, Debug, Hash)]
#[repr(C)]
pub struct __BindgenOpaqueArray<T: Copy, const N: usize>(pub [T; N]);
impl<T: Copy + Default, const N: usize> Default for __BindgenOpaqueArray<T, N> {
    fn default() -> Self {
        Self([<T as Default>::default(); N])
    }
}
pub type std_integral_constant_value_type<_Tp> = _Tp;
pub type std_integral_constant_type = u8;
pub type std_true_type = u8;
pub type std__If = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_iterator_traits {
    pub _address: u8,
}
pub type std_iterator_traits___primary_template = std_iterator_traits;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_iterator {
    pub _address: u8,
}
pub type std_iterator_value_type<_Tp> = _Tp;
pub type std_iterator_difference_type<_Distance> = _Distance;
pub type std_iterator_pointer<_Pointer> = _Pointer;
pub type std_iterator_reference<_Reference> = _Reference;
pub type std_iterator_iterator_category<_Category> = _Category;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_reverse_iterator<_Iter> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Iter>>,
    pub __t_: _Iter,
    pub current: _Iter,
}
pub type std_reverse_iterator_iterator_type<_Iter> = _Iter;
pub type std_reverse_iterator_iterator_category = std__If;
pub type std_reverse_iterator_pointer = std_iterator_traits;
pub type std_reverse_iterator_value_type = std_iterator_traits;
pub type std_reverse_iterator_difference_type = std_iterator_traits;
pub type std_reverse_iterator_reference = std_iterator_traits;
pub type std___allocator_traits_rebind_type = __BindgenOpaqueArray<u8, 0usize>;
pub type std___allocator_traits_rebind_t = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_allocator_traits {
    pub _address: u8,
}
pub type std_allocator_traits_allocator_type<_Alloc> = _Alloc;
pub type std_allocator_traits_value_type = __BindgenOpaqueArray<u8, 0usize>;
pub type std_allocator_traits_pointer = __BindgenOpaqueArray<u8, 0usize>;
pub type std_allocator_traits_const_pointer = __BindgenOpaqueArray<u8, 0usize>;
pub type std_allocator_traits_void_pointer = __BindgenOpaqueArray<u8, 0usize>;
pub type std_allocator_traits_const_void_pointer = __BindgenOpaqueArray<u8, 0usize>;
pub type std_allocator_traits_difference_type = __BindgenOpaqueArray<u8, 0usize>;
pub type std_allocator_traits_size_type = __BindgenOpaqueArray<u8, 0usize>;
pub type std_allocator_traits_propagate_on_container_copy_assignment = u8;
pub type std_allocator_traits_propagate_on_container_move_assignment = u8;
pub type std_allocator_traits_propagate_on_container_swap = u8;
pub type std_allocator_traits_is_always_equal = u8;
pub type std_allocator_traits_rebind_alloc = std___allocator_traits_rebind_t;
pub type std_allocator_traits_rebind_traits = std_allocator_traits;
pub type std___compressed_pair_elem__ParamT<_Tp> = _Tp;
pub type std___compressed_pair_elem_reference<_Tp> = *mut _Tp;
pub type std___compressed_pair_elem_const_reference<_Tp> = *const _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___compressed_pair {
    pub _address: u8,
}
pub type std___compressed_pair__Base1 = u8;
pub type std___compressed_pair__Base2 = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_allocator {
    pub _address: u8,
}
pub type std_allocator_size_type = ::std::os::raw::c_ulong;
pub type std_allocator_difference_type = ::std::os::raw::c_long;
pub type std_allocator_value_type<_Tp> = _Tp;
pub type std_allocator_propagate_on_container_move_assignment = std_true_type;
pub type std_allocator_is_always_equal = std_true_type;
pub type std_allocator_pointer<_Tp> = *mut _Tp;
pub type std_allocator_const_pointer<_Tp> = *const _Tp;
pub type std_allocator_reference<_Tp> = *mut _Tp;
pub type std_allocator_const_reference<_Tp> = *const _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_allocator_rebind {
    pub _address: u8,
}
pub type std_allocator_rebind_other = std_allocator;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___wrap_iter<_Iter> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Iter>>,
    pub __i_: std___wrap_iter_iterator_type<_Iter>,
}
pub type std___wrap_iter_iterator_type<_Iter> = _Iter;
pub type std___wrap_iter_value_type = std_iterator_traits;
pub type std___wrap_iter_difference_type = std_iterator_traits;
pub type std___wrap_iter_pointer = std_iterator_traits;
pub type std___wrap_iter_reference = std_iterator_traits;
pub type std___wrap_iter_iterator_category = std_iterator_traits;
#[repr(C)]
#[derive(Debug)]
pub struct std_vector {
    pub __begin_: std_vector_pointer,
    pub __end_: std_vector_pointer,
    pub __end_cap_: std___compressed_pair,
}
pub type std_vector___default_allocator_type = std_allocator;
pub type std_vector___self = std_vector;
pub type std_vector_value_type<_Tp> = _Tp;
pub type std_vector_allocator_type<_Allocator> = _Allocator;
pub type std_vector___alloc_traits = std_allocator_traits;
pub type std_vector_reference<_Tp> = *mut std_vector_value_type<_Tp>;
pub type std_vector_const_reference<_Tp> = *const std_vector_value_type<_Tp>;
pub type std_vector_size_type = std_vector___alloc_traits;
pub type std_vector_difference_type = std_vector___alloc_traits;
pub type std_vector_pointer = std_vector___alloc_traits;
pub type std_vector_const_pointer = std_vector___alloc_traits;
pub type std_vector_iterator = std___wrap_iter<std_vector_pointer>;
pub type std_vector_const_iterator = std___wrap_iter<std_vector_const_pointer>;
pub type std_vector_reverse_iterator = std_reverse_iterator<std_vector_iterator>;
pub type std_vector_const_reverse_iterator = std_reverse_iterator<std_vector_const_iterator>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_vector___destroy_vector {
    pub __vec_: *mut std_vector,
}
#[repr(C)]
#[derive(Debug)]
pub struct std_vector__ConstructTransaction {
    pub __v_: *mut std_vector,
    pub __pos_: std_vector_pointer,
    pub __new_end_: std_vector_const_pointer,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SpecialWrapper<T> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
    pub value: T,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NestedSpecialWrapper<T> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
    pub inner: SpecialWrapper<T>,
}
pub type VectorSpecialWrapper = NestedSpecialWrapper<std_vector>;
