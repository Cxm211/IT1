/* automatically generated by rust-bindgen 0.71.1 */

#[repr(C, packed)]
pub struct Test<FAM: ?Sized = [::std::os::raw::c_long; 0]> {
    pub Head: ::std::os::raw::c_short,
    pub Tail: FAM,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of Test"][::std::mem::size_of::<Test>() - 2usize];
    ["Alignment of Test"][::std::mem::align_of::<Test>() - 1usize];
    ["Offset of field: Test::Head"][::std::mem::offset_of!(Test, Head) - 0usize];
    ["Offset of field: Test::Tail"][::std::mem::offset_of!(Test, Tail) - 2usize];
};
impl Test<[::std::os::raw::c_long]> {
    pub fn layout(len: usize) -> ::std::alloc::Layout {
        unsafe {
            let p: *const Self = ::std::ptr::from_raw_parts(::std::ptr::null::<()>(), len);
            ::std::alloc::Layout::for_value_raw(p)
        }
    }
    #[inline]
    pub fn fixed(&self) -> (&Test<[::std::os::raw::c_long; 0]>, usize) {
        unsafe {
            let (ptr, len) = (self as *const Self).to_raw_parts();
            (&*(ptr as *const Test<[::std::os::raw::c_long; 0]>), len)
        }
    }
    #[inline]
    pub fn fixed_mut(&mut self) -> (&mut Test<[::std::os::raw::c_long; 0]>, usize) {
        unsafe {
            let (ptr, len) = (self as *mut Self).to_raw_parts();
            (&mut *(ptr as *mut Test<[::std::os::raw::c_long; 0]>), len)
        }
    }
}
impl Test<[::std::os::raw::c_long; 0]> {
    #[doc = r" Convert a sized prefix to an unsized structure with the given length."]
    #[doc = r""]
    #[doc = r" SAFETY: Underlying storage is initialized up to at least `len` elements."]
    pub unsafe fn flex_ref(&self, len: usize) -> &Test<[::std::os::raw::c_long]> {
        Self::flex_ptr(self, len)
    }
    #[doc = r" Convert a mutable sized prefix to an unsized structure with the given length."]
    #[doc = r""]
    #[doc = r" SAFETY: Underlying storage is initialized up to at least `len` elements."]
    #[inline]
    pub unsafe fn flex_ref_mut(&mut self, len: usize) -> &mut Test<[::std::os::raw::c_long]> {
        Self::flex_ptr_mut(self, len).assume_init()
    }
    #[doc = r" Construct DST variant from a pointer and a size."]
    #[doc = r""]
    #[doc = r" NOTE: lifetime of returned reference is not tied to any underlying storage."]
    #[doc = r" SAFETY: `ptr` is valid. Underlying storage is fully initialized up to at least `len` elements."]
    #[inline]
    pub unsafe fn flex_ptr<'unbounded>(
        ptr: *const Self,
        len: usize,
    ) -> &'unbounded Test<[::std::os::raw::c_long]> {
        &*::std::ptr::from_raw_parts(ptr as *const (), len)
    }
    #[doc = r" Construct mutable DST variant from a pointer and a"]
    #[doc = r" size. The returned `&mut` reference is initialized"]
    #[doc = r" pointing to memory referenced by `ptr`, but there's"]
    #[doc = r" no requirement that that memory be initialized."]
    #[doc = r""]
    #[doc = r" NOTE: lifetime of returned reference is not tied to any underlying storage."]
    #[doc = r" SAFETY: `ptr` is valid. Underlying storage has space for at least `len` elements."]
    #[inline]
    pub unsafe fn flex_ptr_mut<'unbounded>(
        ptr: *mut Self,
        len: usize,
    ) -> ::std::mem::MaybeUninit<&'unbounded mut Test<[::std::os::raw::c_long]>> {
        let mut uninit = ::std::mem::MaybeUninit::<&mut Test<[::std::os::raw::c_long]>>::uninit();
        (uninit.as_mut_ptr() as *mut *mut Test<[::std::os::raw::c_long]>)
            .write(::std::ptr::from_raw_parts_mut(ptr as *mut (), len));
        uninit
    }
}
