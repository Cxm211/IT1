/* automatically generated by rust-bindgen */

#[repr(C)]
#[derive(Debug, Copy)]
pub struct i {
    pub j: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_i() {
    assert_eq!(::std::mem::size_of::<i>() , 4usize , concat ! (
               "Size of: " , stringify ! ( i ) ));
    assert_eq! (::std::mem::align_of::<i>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( i ) ));
    assert_eq! (unsafe { & ( * ( 0 as * const i ) ) . j as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( i ) , "::" , stringify
                ! ( j ) ));
}
impl Clone for i {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
pub struct m<k, l> {
    pub _base: l,
    pub o: k,
    pub p: ::std::os::raw::c_long,
    pub q: ::std::os::raw::c_long,
    pub r: ::std::os::raw::c_long,
    pub s: (),
    pub t: bool,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct m_n {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct G<k> {
    pub ag: G_af,
    pub ah: k,
}
pub type G_af = *mut ::std::os::raw::c_void;
pub type aj<k> = G<k>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct u<k> {
    pub a: *mut u<k>,
    pub am: *mut u<k>,
    pub an: aj<k>,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct I {
    pub ap: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_I() {
    assert_eq!(::std::mem::size_of::<I>() , 8usize , concat ! (
               "Size of: " , stringify ! ( I ) ));
    assert_eq! (::std::mem::align_of::<I>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( I ) ));
    assert_eq! (unsafe { & ( * ( 0 as * const I ) ) . ap as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( I ) , "::" , stringify
                ! ( ap ) ));
}
impl Clone for I {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
pub struct JS_v {
    pub ar: m<I, i>,
}
#[test]
fn bindgen_test_layout_JS_v() {
    assert_eq!(::std::mem::size_of::<JS_v>() , 112usize , concat ! (
               "Size of: " , stringify ! ( JS_v ) ));
    assert_eq! (::std::mem::align_of::<JS_v>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( JS_v ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const JS_v ) ) . ar as * const _ as usize } ,
                0usize , concat ! (
                "Alignment of field: " , stringify ! ( JS_v ) , "::" ,
                stringify ! ( ar ) ));
}
#[repr(C)]
pub struct JS_AutoIdVector {
    pub _base: u<JS_v>,
}
#[test]
fn bindgen_test_layout_JS_AutoIdVector() {
    assert_eq!(::std::mem::size_of::<JS_AutoIdVector>() , 136usize , concat !
               ( "Size of: " , stringify ! ( JS_AutoIdVector ) ));
    assert_eq! (::std::mem::align_of::<JS_AutoIdVector>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( JS_AutoIdVector ) ));
}
#[test]
fn __bindgen_test_layout_u_instantiation_81() {
    assert_eq!(::std::mem::size_of::<u<JS_v>>() , 136usize , concat ! (
               "Size of template specialization: " , stringify ! ( u<JS_v> )
               ));
    assert_eq!(::std::mem::align_of::<u<JS_v>>() , 8usize , concat ! (
               "Alignment of template specialization: " , stringify ! (
               u<JS_v> ) ));
}