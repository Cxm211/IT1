/* automatically generated by rust-bindgen */

#[derive(Copy)] pub struct RefPtr<T>(T);

#[repr(C)]
#[derive(Debug, Copy)]
pub struct b {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_b() {
    assert_eq!(::std::mem::size_of::<b>() , 1usize , concat ! (
               "Size of: " , stringify ! ( b ) ));
    assert_eq! (::std::mem::align_of::<b>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( b ) ));
}
impl Clone for b {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct c {
    pub k: l,
}
#[test]
fn bindgen_test_layout_c() {
    assert_eq!(::std::mem::size_of::<c>() , 1usize , concat ! (
               "Size of: " , stringify ! ( c ) ));
    assert_eq! (::std::mem::align_of::<c>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( c ) ));
    assert_eq! (unsafe { & ( * ( 0 as * const c ) ) . k as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( c ) , "::" , stringify
                ! ( k ) ));
}
impl Clone for c {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct B {
    pub d: *mut c,
}
#[test]
fn bindgen_test_layout_B() {
    assert_eq!(::std::mem::size_of::<B>() , 8usize , concat ! (
               "Size of: " , stringify ! ( B ) ));
    assert_eq! (::std::mem::align_of::<B>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( B ) ));
    assert_eq! (unsafe { & ( * ( 0 as * const B ) ) . d as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( B ) , "::" , stringify
                ! ( d ) ));
}
impl Clone for B {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct e {
    pub _address: u8,
}
pub type e_a = b;
#[test]
fn bindgen_test_layout_e() {
    assert_eq!(::std::mem::size_of::<e>() , 1usize , concat ! (
               "Size of: " , stringify ! ( e ) ));
    assert_eq! (::std::mem::align_of::<e>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( e ) ));
}
impl Clone for e {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct f {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_f() {
    assert_eq!(::std::mem::size_of::<f>() , 1usize , concat ! (
               "Size of: " , stringify ! ( f ) ));
    assert_eq! (::std::mem::align_of::<f>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( f ) ));
}
extern "C" {
    #[link_name = "_ZN1fC1E1B"]
    pub fn f_f(this: *mut f, arg1: B);
}
impl Clone for f {
    fn clone(&self) -> Self { *self }
}
impl f {
    #[inline]
    pub unsafe fn new(arg1: B) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        f_f(&mut __bindgen_tmp, arg1);
        __bindgen_tmp
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct i {
    pub h: RefPtr<i_g<T>>,
}
pub type i_g<T> = T;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct l {
    pub j: i,
}
#[test]
fn bindgen_test_layout_l() {
    assert_eq!(::std::mem::size_of::<l>() , 1usize , concat ! (
               "Size of: " , stringify ! ( l ) ));
    assert_eq! (::std::mem::align_of::<l>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( l ) ));
    assert_eq! (unsafe { & ( * ( 0 as * const l ) ) . j as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( l ) , "::" , stringify
                ! ( j ) ));
}
impl Clone for l {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "_Z25Servo_Element_GetSnapshotv"]
    pub fn Servo_Element_GetSnapshot() -> e;
}